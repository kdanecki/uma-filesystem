use std::{
    ffi::CStr,
    os::unix::process::parent_id,
    time::{SystemTime, UNIX_EPOCH},
};

use zerocopy::FromZeros;

/* automatically generated by rust-bindgen 0.70.1 */
#[derive(Debug)]
pub struct Foo {
    pub x: i32,
}

#[derive(Debug)]
pub struct FileSystem<'a> {
    sb: superblock_t,
    data: &'a mut [u8],
    // inode_bitmap: block_p,
    // inodes: block_p,
    // blocks_bitmap: block_p,
    // first_block: block_p,
    inode_bitmap: Bitmap<'a>,
    inodes: &'a mut [u8],
    blocks_bitmap: Bitmap<'a>,
    data_blocks: &'a mut [u8],
}

impl<'a> FileSystem<'a> {
    pub fn new(data: &'a mut [u8]) -> Self {
        let sb_data: [u8; 28] = data[0..28].try_into().unwrap();
        let mut sb: superblock_t = zerocopy::transmute!(sb_data);
        sb.block_size = 1024;
        sb.blocks_num = 16384;
        sb.inodes_num = 1024 * 8;

        let inode_bitmap_id = 1;
        let inodes_id = if sb.inodes_num % (8 * sb.block_size) == 0 {
            sb.inodes_num / (8 * sb.block_size) + inode_bitmap_id
        } else {
            sb.inodes_num / (8 * sb.block_size) + 2
        };

        let blocks_bitmap_id = if (sb.inodes_num * 128) % (sb.block_size) == 0 {
            (sb.inodes_num * 128) / (sb.block_size) + inodes_id
        } else {
            (sb.inodes_num * 128) / (sb.block_size) + inodes_id + 1
        };

        let data_blocks = sb.blocks_num - blocks_bitmap_id;
        let first_block_id = if data_blocks % (8 * sb.block_size) == 0 {
            data_blocks / (8 * sb.block_size) + blocks_bitmap_id
        } else {
            data_blocks / (8 * sb.block_size) + blocks_bitmap_id + 1
        };

        let (data, blocks_data) = data.split_at_mut((first_block_id * sb.block_size) as usize);
        let (data, blocks_bitmap_data) =
            data.split_at_mut((blocks_bitmap_id * sb.block_size) as usize);
        let (data, inodes_data) = data.split_at_mut((inodes_id * sb.block_size) as usize);
        let (data, inodes_bitmap_data) = data.split_at_mut(sb.block_size as usize);
        let inode_bitmap = Bitmap::new(inodes_bitmap_data, sb.inodes_num as usize);
        let blocks_bitmap = Bitmap::new(blocks_bitmap_data, data_blocks as usize);
        println!(
            "{inodes_id} {blocks_bitmap_id} {first_block_id} {}",
            sb.blocks_num - first_block_id
        );

        Self {
            sb,
            data,
            inode_bitmap,
            inodes: inodes_data,
            blocks_bitmap,
            data_blocks: blocks_data,
        }
    }

    pub fn format(&mut self, block_size: u32, block_num: u32) {
        self.sb.header = [0x58, 0x44, 0x20, 0x20, 0x20, 0x20, 0x58, 0x44];
        self.sb.blocks_num = block_num;
        self.sb.block_size = block_size;
        self.sb.inodes_num = 1024 * 8;
        //self.inode_bitmap.take(1);
        //self.blocks_bitmap.take(1);
        self.save();
        self.create_inode(1, 1, 0, 2);

        // TODO fix this
        let inode_num = 1;
        let mut data = [0u8; 22];
        data[..4].copy_from_slice(&(inode_num as u32).to_le_bytes());
        data[4..8].copy_from_slice(&1u32.to_le_bytes());
        data[8..9].copy_from_slice(".".as_bytes());

        data[12..16].copy_from_slice(&(inode_num as u32).to_le_bytes());
        data[16..20].copy_from_slice(&2u32.to_le_bytes());
        data[20..22].copy_from_slice("..".as_bytes());
        self.get_data_block_mut(1 as u32)[0..data.len()].copy_from_slice(&data);
        self.inode_bitmap.take(1);
        self.blocks_bitmap.take(1);
    }

    pub fn rename(&mut self, from: &CStr, to: &CStr) -> Result<(), &str> {
        let from = from.to_str().expect("path should be UTF-8");
        let to = to.to_str().expect("path should be UTF-8");
        if let Some(offset) = from.rfind('/') {
            if let Some(dir_from) = if offset == 0 {
                Some(self.get_inode_by_id(1))
            } else {
                self.find_file(&from[..offset])
            } {
                if dir_from.type_perm == 2 {
                    if let Some(id) = self.search_directory_get_id(&dir_from, &from[offset + 1..]) {
                        if let Some(_) = self.find_file(to) {
                            return Err("file already exists");
                        }
                        if let Some(to_offset) = to.rfind('/') {
                            if let Some(dir_to) = if to_offset == 0 {
                                Some(self.get_inode_by_id(1))
                            } else {
                                self.find_file(&to[..to_offset])
                            } {
                                self.clear_dentry(&dir_from, &from[offset + 1..]);

                                // create dentry
                                let name = &to[to_offset + 1..].as_bytes();
                                let data = self.get_data_block_mut(dir_to.direct_blocks[0]);
                                let data = FileSystem::find_space_for_dentry(data, name.len() + 8)
                                    .unwrap();

                                data[..4].copy_from_slice(&(id as u32).to_le_bytes());
                                let name_len = name.len();
                                data[4..8].copy_from_slice(&(name_len as u32).to_le_bytes());
                                data[8..8 + name_len].copy_from_slice(name);
                                return Ok(());
                            }
                            return Err("target dir nonexisting");
                        }
                    }
                }
            }
            return Err("file not found");
        } else {
            return Err("bad filename format");
        }
        Err("file not found")
    }

    pub fn save(&mut self) {
        let d: [u8; 28] = zerocopy::transmute!(self.sb);
        self.data[..28].copy_from_slice(&d);
    }

    pub fn get_attr(&self, path: &CStr) -> Option<inode_t> {
        self.find_file(path.to_str().unwrap())
    }

    pub fn create_file(&mut self, path: &CStr, content: &[u8]) -> Result<(), &str> {
        return self.create_file_inter(path, content, 1);
    }

    pub fn unlink_file(&mut self, path: &CStr) -> Result<(), &str> {
        // TODO check nlink
        let path = path.to_str().unwrap();
        if let Some(offset) = path.rfind('/') {
            if let Some(node) = if offset == 0 {
                Some(self.get_inode_by_id(1))
            } else {
                self.find_file(&path[..offset])
            } {
                if node.type_perm == 2 {
                    if let Some(id) = self.search_directory_get_id(&node, &path[offset + 1..]) {
                        let file = self.get_inode_by_id(id);
                        self.blocks_bitmap.free(file.direct_blocks[0] as usize);
                        self.inode_bitmap.free(id as usize);
                        self.clear_dentry(&node, &path[offset + 1..]);

                        return Ok(());
                    }
                }
            }
            return Err("file not found");
        } else {
            return Err("bad filename format");
        }
    }

    pub fn unlink_dir(&mut self, path: &CStr) -> Result<(), &str> {
        let path = path.to_str().unwrap();
        if let Some(offset) = path.rfind('/') {
            if let Some(node) = if offset == 0 {
                Some(self.get_inode_by_id(1))
            } else {
                self.find_file(&path[..offset])
            } {
                if node.type_perm == 2 {
                    if let Some(id) = self.search_directory_get_id(&node, &path[offset + 1..]) {
                        let file = self.get_inode_by_id(id);
                        if file.type_perm == 2 {
                            let mut data = self.get_data_block(file.direct_blocks[0]);
                            while let Some(d) = Dentry::from(&data[..]) {
                                println!("{:?}", d);
                                if !(d.name == "." || d.name == "..") {
                                    return Err("directory not empty");
                                }
                                data = &data[d.size..];
                            }
                            self.blocks_bitmap.free(file.direct_blocks[0] as usize);
                            self.inode_bitmap.free(id as usize);
                            self.clear_dentry(&node, &path[offset + 1..]);

                            return Ok(());
                        }
                        return Err("not a directory");
                    }
                }
            }
            return Err("file not found");
        }
        Err("bad filename format")
    }

    fn find_file(&self, path: &str) -> Option<inode_t> {
        let root = self.get_inode_by_id(1);
        if path == "/" {
            return Some(root);
        }
        if &path[0..1] == "/" {
            return self.find_file_inter(&root, &path[1..]);
        }
        None
    }

    fn find_file_inter(&self, node: &inode_t, path: &str) -> Option<inode_t> {
        if let Some(offset) = path.find('/') {
            let filename = &path[0..offset];
            // println!("{:?}", filename.as_bytes());
            if let Some(sub_node) = self.search_directory(node, filename) {
                if sub_node.type_perm == 2 {
                    // println!(
                    //     "subnode foid off {}searching {}",
                    //     offset,
                    //     &path[offset + 1..]
                    // );
                    return self.find_file_inter(&sub_node, &path[offset + 1..]);
                }
            } else {
                return None;
            }
        } else {
            return self.search_directory(node, path);
        };

        None
    }

    fn find_file_mut(&self, path: &str) -> Option<(inode_t, inode_p)> {
        let root = self.get_inode_by_id(1);
        if path == "/" {
            return Some((root, 1));
        }
        if &path[0..1] == "/" {
            return self.find_file_mut_inter(&root, &path[1..]);
        }
        None
    }

    fn find_file_mut_inter(&self, node: &inode_t, path: &str) -> Option<(inode_t, inode_p)> {
        if let Some(offset) = path.find('/') {
            let filename = &path[0..offset];
            // println!("{:?}", filename.as_bytes());
            if let Some(sub_node) = self.search_directory(node, filename) {
                if sub_node.type_perm == 2 {
                    // println!(
                    //     "subnode foid off {}searching {}",
                    //     offset,
                    //     &path[offset + 1..]
                    // );
                    return self.find_file_mut_inter(&sub_node, &path[offset + 1..]);
                }
            } else {
                return None;
            }
        } else {
            if let Some(id) = self.search_directory_get_id(node, path) {
                return Some((self.get_inode_by_id(id), id));
            }
        };

        None
    }

    pub fn create_directory(&mut self, path: &CStr) -> Result<(), &str> {
        let data = vec![0; self.sb.block_size as usize];
        self.create_file_inter(path, &data, 2)
    }

    pub fn write_file(&mut self, path: &CStr, content: &[u8]) -> i32 {
        if let Some((mut node, id)) = self.find_file_mut(path.to_str().unwrap()) {
            self.get_data_block_mut(node.direct_blocks[0])[0..content.len()]
                .copy_from_slice(content);
            node.size = content.len() as u32;
            self.save_inode(id, node);
            return content.len() as i32;
        } else {
            println!("file not found");
            return 0;
        }
    }

    pub fn read_file(&self, path: &CStr) -> Option<&[u8]> {
        if let Some(node) = self.find_file(path.to_str().unwrap()) {
            // println!(
            //     "reading from node {:#?} block {}",
            //     node, node.direct_blocks[0]
            // );
            return Some(&self.get_data_block(node.direct_blocks[0])[0..node.size as usize]);
        }
        None
    }

    fn create_file_inter(
        &mut self,
        path: &CStr,
        content: &[u8],
        type_perm: u16,
    ) -> Result<(), &str> {
        // if !(path.count_bytes() > 0 && &path.to_str().unwrap()[0..1] == "/") {
        //     return Err("invalid path");
        // }
        // let path = &path[1..];
        let path_str = path.to_str().unwrap();
        let mut node;
        let filename;

        if let Some(end) = path_str.rfind('/') {
            if end == 0 {
                node = self.get_inode_by_id(1);
                filename = &path[1..];
            } else {
                node = self.find_file(&path_str[0..end]).expect("file not found");
                filename = &path[end + 1..];
            }
        } else {
            return Err("invalid path");
        }

        if self
            .search_directory(&mut node, filename.to_str().unwrap())
            .is_some()
        {
            return Err("file already exists");
        }
        let name = filename.to_bytes();

        let mut i = 0usize;
        let inode_num = self.inode_bitmap.get_first_free();
        let block_num = self.blocks_bitmap.get_first_free();

        //create dentry
        // if node.direct_blocks[0] == 0 {
        //     node.direct_blocks[0] = self.blocks_bitmap.get_first_free() as u32;
        //     println!("occupy block");
        // }
        let data = self.get_data_block_mut(node.direct_blocks[0]);
        let data = FileSystem::find_space_for_dentry(data, name.len() + 8).unwrap();

        data[..4].copy_from_slice(&(inode_num as u32).to_le_bytes());
        let name_len = name.len();
        data[4..8].copy_from_slice(&(name_len as u32).to_le_bytes());
        data[8..8 + name_len].copy_from_slice(name);

        //create inode
        self.create_inode(inode_num, block_num, content.len() as u32, type_perm);

        //create data block
        self.get_data_block_mut(block_num as u32)[0..content.len()].copy_from_slice(content);
        if type_perm == 2 {
            let mut data = [0u8; 22];
            data[..4].copy_from_slice(&(inode_num as u32).to_le_bytes());
            data[4..8].copy_from_slice(&1u32.to_le_bytes());
            data[8..9].copy_from_slice(".".as_bytes());

            let parent_id = self
                .search_directory_get_id(&node, ".")
                .expect("parent does not have \".\"");
            data[12..16].copy_from_slice(&(parent_id as u32).to_le_bytes());
            data[16..20].copy_from_slice(&2u32.to_le_bytes());
            data[20..22].copy_from_slice("..".as_bytes());
            self.get_data_block_mut(block_num as u32)[0..data.len()].copy_from_slice(&data);
        }

        Ok(())
    }

    fn find_space_for_dentry(data: &mut [u8], required_size: usize) -> Option<&mut [u8]> {
        let mut start = 0;
        let mut found = 0;
        let mut i = 0;
        while i + 4 < data.len() {
            if u32::from_le_bytes(data[i..i + 4].try_into().unwrap()) == 0 {
                if found > 0 {
                    found += 4;
                    if found >= required_size {
                        return Some(&mut data[start..start + found as usize]);
                    }
                } else {
                    start = i;
                    found = 4;
                }
            } else {
                found = 0;
            }
            i += 4;
        }

        None
    }

    pub fn get_files_in_dir(&self, path: &CStr) -> Vec<String> {
        let mut files = vec![];
        if let Some(node) = self.find_file(path.to_str().unwrap()) {
            if node.type_perm == 2 {
                let mut data = self.get_data_block(node.direct_blocks[0]);
                while let Some(dentry) = Dentry::from(data) {
                    files.push(String::from(dentry.name));
                    data = &data[dentry.size..];
                }
            }
        }
        return files;
    }

    pub fn dummy_data(&mut self) {
        println!(
            "create foo {:?}",
            self.create_file(c"/foo", &['L' as u8, 'O' as u8, 'L' as u8, 0])
        );
        println!(
            "create boo {:?}",
            self.create_file(c"/boo", &['M' as u8, 'O' as u8, 'L' as u8, 0])
        );
        println!("{:?}", self.create_directory(c"/XD"));
        println!("{:?}", self.create_file(c"/XD/xd", &[1u8, 2, 3, 4, 5]));
        // self.create_file(
        //     c"goo",
        //     &[1u8, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],
        // );
        println!("READS");
        println!(
            "foo: {:?}",
            CStr::from_bytes_until_nul(self.read_file(c"/foo").unwrap())
        );
        println!("foo: {:?}", self.read_file(c"/foo").unwrap());
        println!("boo: {:?}", self.read_file(c"/boo").unwrap());
        println!("XD: {:?}", self.read_file(c"/XD").unwrap());
        println!("xd: {:?}", self.read_file(c"/XD/xd").unwrap());
        self.write_file(c"/XD/xd", &[5, 4, 3, 2, 1]);
        println!("xd: {:?}", self.read_file(c"/XD/xd").unwrap());
        println!("{:?}", self.create_file(c"/XD/xd", &[0u8]));
        println!("{:?}", self.create_directory(c"/XD/LUL"));
        println!("{:?}", self.create_file(c"/XD/LUL/cos tam", &[5u8, 5, 5]));
        println!("xd: {:?}", self.read_file(c"/XD/LUL/cos tam").unwrap());
        println!("DELETE");
        println!("{:?}", self.unlink_file(c"/boo"));
        println!("XD: {:?}", self.read_file(c"/XD").unwrap());
        println!("xd: {:?}", self.read_file(c"/XD/LUL/cos tam").unwrap());
        println!("del XD {:?}", self.unlink_dir(c"/XD"));
        println!(
            "{:?}",
            self.create_file(c"/asdfghjkl", &['M' as u8, 'O' as u8, 'L' as u8, 0])
        );
        println!(
            "{:?}",
            self.create_file(c"/g", &['M' as u8, 'O' as u8, 'L' as u8, 0])
        );
        self.unlink_file(c"/g").expect("failed to delete");
        self.unlink_file(c"/XD/LUL/cos tam")
            .expect("failed to delete");
        println!("delete LUL {:?}", self.unlink_dir(c"/XD/LUL"));
        println!(
            "{:?}",
            self.create_file(c"/qwertyui", &['M' as u8, 'O' as u8, 'L' as u8, 0])
        );
    }

    pub fn test(&self) {
        println!("SUPERB {:?}", self.sb);
        //println!("{:?}", self.get_inode_by_id(1));
        //println!("{:?}", self.get_inode_by_id(2));
        println!("{:?}", self.find_file("/foo"));
    }

    fn clear_dentry(&mut self, node: &inode_t, filename: &str) {
        let mut i = 0usize;
        let data = self.get_data_block_mut(node.direct_blocks[0]);

        //println!("searching filename {}", filename);
        while let Some(mut dentry) = DentryMut::from(&mut data[i..]) {
            // println!("{i}");
            if dentry.get_name() == filename {
                dentry.delete();
                return;
            }
            i += dentry.size;
        }
        panic!("tried to delete inexisting entry");
    }

    fn search_directory_get_id(&self, node: &inode_t, filename: &str) -> Option<inode_p> {
        let mut i = 0usize;
        let data = self.get_data_block(node.direct_blocks[0]);

        //println!("searching filename {}", filename);
        while let Some(dentry) = Dentry::from(&data[i..]) {
            if dentry.name == filename {
                //println!("inode num {}", dentry.inode_num);
                return Some(dentry.inode_num);
            } else {
                // println!("{:?} {:?}", dentry.name.as_bytes(), filename.as_bytes());
                // println!("{:?} {:?}", dentry.name, filename);
            }
            i += dentry.size;
            // println!("{i}");
        }
        None
    }

    fn search_directory(&self, node: &inode_t, filename: &str) -> Option<inode_t> {
        if let Some(id) = self.search_directory_get_id(node, filename) {
            return Some(self.get_inode_by_id(id));
        }
        None
    }

    fn get_inode_by_id(&self, id: inode_p) -> inode_t {
        if id == 0 {
            panic!("invalid inode id");
        }
        let start = (128 * id) as usize;
        let data: [u8; 128] = self.inodes[start..start + 128]
            .try_into()
            .expect(&format!("failed to load inode {}", id));
        zerocopy::transmute!(data)
    }

    // pub fn get_inode(&mut self, path: &CStr) {
    //     let d: [u8; 128] = self.inodes[0..128].try_into().unwrap();
    //     let root: inode_t = zerocopy::transmute!(d);
    //     self.search_directory(&root, path);
    // }

    pub fn create_inode(&mut self, id: usize, first_block: usize, size: u32, type_perm: u16) {
        // let i = self.inode_bitmap.get_first_free();
        let mut blocks = [0u32; 12];
        blocks[0] = first_block as u32; //self.blocks_bitmap.get_first_free() as u32;
                                        // println!("block {}", blocks[0]);
        let time = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .expect("time went back")
            .as_secs();
        //let data: [u8; 128] = .try_into().unwrap();
        let node = inode_t {
            type_perm,
            uid: 1,
            gid: 1,
            pad1: 0,
            size,
            pad2: 0,
            access_time: time,
            mod_time: time,
            creat_time: time,
            hard_links: 2,
            direct_blocks: blocks,
            sin_inblock: 0,
            dob_inblock: 0,
            tri_inblock: 0,
            unused: [0i8; 24],
        };
        let data: [u8; 128] = zerocopy::transmute!(node);
        self.inodes[id * 128..(id + 1) * 128].copy_from_slice(&data);
    }

    fn save_inode(&mut self, id: inode_p, node: inode_t) {
        let id = id as usize;
        let data: [u8; 128] = zerocopy::transmute!(node);
        self.inodes[id * 128..(id + 1) * 128].copy_from_slice(&data);
    }

    fn get_data_block_mut(&mut self, id: block_p) -> &mut [u8] {
        let offset = (id * self.sb.block_size) as usize;
        return &mut self.data_blocks[offset..offset + self.sb.block_size as usize];
    }

    fn get_data_block(&self, id: block_p) -> &[u8] {
        let offset = (id * self.sb.block_size) as usize;
        return &self.data_blocks[offset..offset + self.sb.block_size as usize];
    }

    fn get_blocks_mut(&mut self, start: block_p, end: block_p) -> &mut [u8] {
        let s = (start * self.sb.block_size) as usize;
        let e = (end * self.sb.block_size) as usize;
        return &mut self.data[s..e];
    }

    fn get_blocks(&self, start: block_p, end: block_p) -> &[u8] {
        let s = (start * self.sb.block_size) as usize;
        let e = (end * self.sb.block_size) as usize;
        return &self.data[s..e];
    }

    fn get_block(&self, id: block_p) -> &[u8] {
        let start = (id * self.sb.block_size) as usize;
        let end = start + self.sb.block_size as usize;
        return &self.data[start..end];
    }

    //    fn find_free_inode(&self) -> inode_t {}
}

#[derive(Debug)]
struct Bitmap<'a> {
    data: &'a mut [u8],
    size: usize,
}

impl<'a> Bitmap<'a> {
    pub fn new(data: &'a mut [u8], size: usize) -> Self {
        if (data.len() * 8 < size) {
            panic!("buffer to small to create bitmap");
        }
        Bitmap { data, size }
    }

    pub fn take(&mut self, id: usize) {
        self.data[id / 8] |= 1 << id % 8;
        // println!("{:?}", self.data);
    }

    pub fn free(&mut self, id: usize) {
        self.data[id / 8] &= !(1 << id % 8);
    }

    pub fn get_first_free(&mut self) -> usize {
        let mut i = 1;
        while i < self.size {
            if self.data[i / 8] & 1 << i % 8 == 0 {
                self.data[i / 8] |= 1 << i % 8;
                return i;
            }
            i += 1;
        }
        return 0;
    }
}

#[derive(Debug)]
struct Dentry<'a> {
    inode_num: inode_p,
    name: &'a str,
    size: usize,
}

impl<'a> Dentry<'a> {
    fn from(data: &'a [u8]) -> Option<Self> {
        let mut data = &data[..];
        let mut i = 0;
        // println!("foo {i} {:?}", &data[0..4]);
        while data.len() >= 8 && u32::from_le_bytes(data[0..4].try_into().unwrap()) == 0 {
            // println!("ups");
            i += 4;
            data = &data[4..];
        }
        if data.len() < 8 {
            // println!("too small");
            return None;
            //"dentry too small"
        }
        let inode_num = inode_p::from_le_bytes(data[0..4].try_into().unwrap());
        if inode_num == 0 {
            println!("inode 0");
            return None;
        }
        let size = u32::from_le_bytes(data[4..8].try_into().unwrap());
        if data.len() < (8 + size) as usize {
            println!("size wrong");
            println!("{} {}", data.len(), 8 + size);
            return None;
            //"dir name size incorrect"
        }
        Some(Self {
            inode_num,
            name: std::str::from_utf8(&data[8..8 + size as usize]).expect(&format!(
                "bad file name {:?} size = {}",
                &data[8..8 + size as usize],
                size
            )),
            size: match size % 4 {
                0 => size as usize + 8 + i,
                1 => size as usize + 8 + i + 3,
                2 => size as usize + 8 + i + 2,
                3 => size as usize + 8 + i + 1,
                _ => unreachable!("modulo lol"),
            },
        })
    }
}

struct DentryMut<'a> {
    inode_num: inode_p,
    size: usize,
    data: &'a mut [u8],
}

impl<'a> DentryMut<'a> {
    fn from(data: &'a mut [u8]) -> Option<Self> {
        let mut data = &mut data[..];
        let mut i = 0;
        while data.len() >= 8 && u32::from_le_bytes(data[0..4].try_into().unwrap()) == 0 {
            data = &mut data[4..];
            i += 4;
        }
        if data.len() < 8 {
            println!("too small");
            return None;
            //"dentry too small"
        }
        let inode_num = inode_p::from_le_bytes(data[0..4].try_into().unwrap());
        if inode_num == 0 {
            println!("inode 0");
            return None;
        }
        let size = u32::from_le_bytes(data[4..8].try_into().unwrap());
        if data.len() < (8 + size) as usize {
            println!("size wrong");
            return None;
            //"dir name size incorrect"
        }
        Some(Self {
            inode_num,
            // size: size as usize + 8,
            size: match size % 4 {
                0 => size as usize + 8 + i,
                1 => size as usize + 8 + i + 3,
                2 => size as usize + 8 + i + 2,
                3 => size as usize + 8 + i + 1,
                _ => unreachable!("modulo lol"),
            },
            data: &mut data[..8 + size as usize],
        })
    }

    fn delete(&mut self) {
        self.data.zero();
    }

    fn get_name(&self) -> &str {
        std::str::from_utf8(&self.data[8..])
            .expect(&format!("bad file name {:?}", &self.data[8..],))
    }
}

#[repr(C)]
#[derive(Debug, Copy, Clone, zerocopy_derive::FromBytes, zerocopy_derive::IntoBytes)]
pub struct superblock_t {
    pub header: [::std::os::raw::c_char; 8usize],
    pub inodes_num: ::std::os::raw::c_uint,
    pub blocks_num: ::std::os::raw::c_uint,
    pub block_size: ::std::os::raw::c_uint,
    pub free_blocks: ::std::os::raw::c_uint,
    pub free_inodes: ::std::os::raw::c_uint,
}

#[derive(Debug)]
pub struct Goo<const T: usize> {
    pub goo: [u8; T],
}

//#[repr()]
#[derive(zerocopy_derive::FromBytes, zerocopy_derive::IntoBytes, Debug)]
pub struct Boo {
    pub x: f32,
    pub y: f32,
    pub c: [u8; 20],
}

impl From<[i8; 8]> for superblock_t {
    fn from(value: [i8; 8]) -> Self {
        superblock_t {
            header: [0; 8],
            inodes_num: 1, //u32::from_le_bytes(value[4..].try_into().unwrap()),
            blocks_num: 1, /*value[0..4].try_into().unwrap()*/
            block_size: 1,
            free_blocks: 1,
            free_inodes: 1,
        }
    }
}

impl From<Foo> for superblock_t {
    fn from(value: Foo) -> Self {
        superblock_t {
            header: [0; 8],
            inodes_num: value.x as u32,
            blocks_num: 1,
            block_size: 1,
            free_blocks: 1,
            free_inodes: 1,
        }
    }
}

#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of superblock_t"][::std::mem::size_of::<superblock_t>() - 28usize];
    ["Alignment of superblock_t"][::std::mem::align_of::<superblock_t>() - 4usize];
    ["Offset of field: superblock_t::header"]
        [::std::mem::offset_of!(superblock_t, header) - 0usize];
    ["Offset of field: superblock_t::inodes_num"]
        [::std::mem::offset_of!(superblock_t, inodes_num) - 8usize];
    ["Offset of field: superblock_t::blocks_num"]
        [::std::mem::offset_of!(superblock_t, blocks_num) - 12usize];
    ["Offset of field: superblock_t::block_size"]
        [::std::mem::offset_of!(superblock_t, block_size) - 16usize];
    ["Offset of field: superblock_t::free_blocks"]
        [::std::mem::offset_of!(superblock_t, free_blocks) - 20usize];
    ["Offset of field: superblock_t::free_inodes"]
        [::std::mem::offset_of!(superblock_t, free_inodes) - 24usize];
};
pub type block_p = ::std::os::raw::c_uint;
pub type inode_p = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, zerocopy_derive::FromBytes, zerocopy_derive::IntoBytes)]
pub struct inode_t {
    pub type_perm: ::std::os::raw::c_ushort,
    pub uid: ::std::os::raw::c_ushort,
    pub gid: ::std::os::raw::c_ushort,
    pub pad1: ::std::os::raw::c_ushort,
    pub size: ::std::os::raw::c_uint,
    pub pad2: ::std::os::raw::c_uint,
    pub access_time: ::std::os::raw::c_ulonglong,
    pub mod_time: ::std::os::raw::c_ulonglong,
    pub creat_time: ::std::os::raw::c_ulonglong,
    pub hard_links: ::std::os::raw::c_uint,
    pub direct_blocks: [block_p; 12usize],
    pub sin_inblock: block_p,
    pub dob_inblock: block_p,
    pub tri_inblock: block_p,
    pub unused: [::std::os::raw::c_char; 24usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of inode_t"][::std::mem::size_of::<inode_t>() - 128usize];
    ["Alignment of inode_t"][::std::mem::align_of::<inode_t>() - 8usize];
    ["Offset of field: inode_t::type_perm"][::std::mem::offset_of!(inode_t, type_perm) - 0usize];
    ["Offset of field: inode_t::uid"][::std::mem::offset_of!(inode_t, uid) - 2usize];
    ["Offset of field: inode_t::gid"][::std::mem::offset_of!(inode_t, gid) - 4usize];
    ["Offset of field: inode_t::size"][::std::mem::offset_of!(inode_t, size) - 8usize];
    ["Offset of field: inode_t::access_time"]
        [::std::mem::offset_of!(inode_t, access_time) - 16usize];
    ["Offset of field: inode_t::mod_time"][::std::mem::offset_of!(inode_t, mod_time) - 24usize];
    ["Offset of field: inode_t::creat_time"][::std::mem::offset_of!(inode_t, creat_time) - 32usize];
    ["Offset of field: inode_t::hard_links"][::std::mem::offset_of!(inode_t, hard_links) - 40usize];
    ["Offset of field: inode_t::direct_blocks"]
        [::std::mem::offset_of!(inode_t, direct_blocks) - 44usize];
    ["Offset of field: inode_t::sin_inblock"]
        [::std::mem::offset_of!(inode_t, sin_inblock) - 92usize];
    ["Offset of field: inode_t::dob_inblock"]
        [::std::mem::offset_of!(inode_t, dob_inblock) - 96usize];
    ["Offset of field: inode_t::tri_inblock"]
        [::std::mem::offset_of!(inode_t, tri_inblock) - 100usize];
    ["Offset of field: inode_t::unused"][::std::mem::offset_of!(inode_t, unused) - 104usize];
};
extern "C" {
    pub fn get_block(sb: *mut superblock_t, id: block_p) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn get_inode_by_id(sb: *mut superblock_t, id: inode_p) -> *mut inode_t;
}
extern "C" {
    pub fn take_inode(sb: *mut superblock_t, id: inode_p);
}
extern "C" {
    pub fn get_free_data_block(sb: *mut superblock_t) -> block_p;
}
extern "C" {
    pub fn test(sb: *mut superblock_t);
}
extern "C" {
    pub fn find_free_inode(sb: *mut superblock_t) -> inode_p;
}
extern "C" {
    pub fn find_inode_by_path(
        sb: *mut superblock_t,
        path: *const ::std::os::raw::c_char,
    ) -> *mut inode_t;
}
extern "C" {
    pub fn search_dir(cur: *mut inode_t, path: *const ::std::os::raw::c_char) -> *mut inode_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dentry_t_t {
    pub inode: inode_p,
    pub size: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of dentry_t_t"][::std::mem::size_of::<dentry_t_t>() - 8usize];
    ["Alignment of dentry_t_t"][::std::mem::align_of::<dentry_t_t>() - 4usize];
    ["Offset of field: dentry_t_t::inode"][::std::mem::offset_of!(dentry_t_t, inode) - 0usize];
    ["Offset of field: dentry_t_t::size"][::std::mem::offset_of!(dentry_t_t, size) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filesystem_t {
    pub sb: superblock_t,
    pub inodes: *mut inode_t,
    pub blocks: *mut block_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of filesystem_t"][::std::mem::size_of::<filesystem_t>() - 48usize];
    ["Alignment of filesystem_t"][::std::mem::align_of::<filesystem_t>() - 8usize];
    ["Offset of field: filesystem_t::sb"][::std::mem::offset_of!(filesystem_t, sb) - 0usize];
    ["Offset of field: filesystem_t::inodes"]
        [::std::mem::offset_of!(filesystem_t, inodes) - 32usize];
    ["Offset of field: filesystem_t::blocks"]
        [::std::mem::offset_of!(filesystem_t, blocks) - 40usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct block_t {
    pub _address: u8,
}
