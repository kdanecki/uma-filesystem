use std::{
    ffi::CStr,
    time::{SystemTime, UNIX_EPOCH},
};

/* automatically generated by rust-bindgen 0.70.1 */
#[derive(Debug)]
pub struct Foo {
    pub x: i32,
}

#[derive(Debug)]
pub struct FileSystem<'a> {
    sb: superblock_t,
    data: &'a mut [u8],
    // inode_bitmap: block_p,
    // inodes: block_p,
    // blocks_bitmap: block_p,
    // first_block: block_p,
    inode_bitmap: Bitmap<'a>,
    inodes: &'a mut [u8],
    blocks_bitmap: Bitmap<'a>,
    data_blocks: &'a mut [u8],
}

impl<'a> FileSystem<'a> {
    pub fn new(data: &'a mut [u8]) -> Self {
        let sb_data: [u8; 28] = data[0..28].try_into().unwrap();
        let mut sb: superblock_t = zerocopy::transmute!(sb_data);
        sb.block_size = 1024;
        sb.blocks_num = 16384;
        sb.inodes_num = 1024 * 8;

        let inode_bitmap_id = 1;
        let inodes_id = if sb.inodes_num % (8 * sb.block_size) == 0 {
            sb.inodes_num / (8 * sb.block_size) + inode_bitmap_id
        } else {
            sb.inodes_num / (8 * sb.block_size) + 2
        };

        let blocks_bitmap_id = if (sb.inodes_num * 128) % (sb.block_size) == 0 {
            (sb.inodes_num * 128) / (sb.block_size) + inodes_id
        } else {
            (sb.inodes_num * 128) / (sb.block_size) + inodes_id + 1
        };

        let data_blocks = sb.blocks_num - blocks_bitmap_id;
        let first_block_id = if data_blocks % (8 * sb.block_size) == 0 {
            data_blocks / (8 * sb.block_size) + blocks_bitmap_id
        } else {
            data_blocks / (8 * sb.block_size) + blocks_bitmap_id + 1
        };

        let (data, blocks_data) = data.split_at_mut((first_block_id * sb.block_size) as usize);
        let (data, blocks_bitmap_data) =
            data.split_at_mut((blocks_bitmap_id * sb.block_size) as usize);
        let (data, inodes_data) = data.split_at_mut((inodes_id * sb.block_size) as usize);
        let (data, inodes_bitmap_data) = data.split_at_mut(sb.block_size as usize);
        let inode_bitmap = Bitmap::new(inodes_bitmap_data, sb.inodes_num as usize);
        let blocks_bitmap = Bitmap::new(blocks_bitmap_data, data_blocks as usize);
        println!(
            "{inodes_id} {blocks_bitmap_id} {first_block_id} {}",
            sb.blocks_num - first_block_id
        );

        Self {
            sb,
            data,
            inode_bitmap,
            inodes: inodes_data,
            blocks_bitmap,
            data_blocks: blocks_data,
        }
    }

    pub fn format(&mut self, block_size: u32, block_num: u32) {
        self.sb.header = [0x58, 0x44, 0x20, 0x20, 0x20, 0x20, 0x58, 0x44];
        self.sb.blocks_num = block_num;
        self.sb.block_size = block_size;
        self.sb.inodes_num = 1024 * 8;
        //self.inode_bitmap.take(1);
        //self.blocks_bitmap.take(1);
        self.save();
        self.create_inode(1, 1);
        self.inode_bitmap.take(1);
        self.blocks_bitmap.take(1);
    }

    pub fn save(&mut self) {
        let d: [u8; 28] = zerocopy::transmute!(self.sb);
        self.data[..28].copy_from_slice(&d);
    }

    pub fn create_file(&mut self, path: &CStr, content: &[u8]) {
        self.create_file_inter(&self.get_inode_by_id(1), path.to_bytes_with_nul(), content);
    }
    pub fn read_file(&self, path: &CStr) -> Option<&[u8]> {
        if let Some(node) = self.search_directory(&self.get_inode_by_id(1), path) {
            // println!(
            //     "reading from node {:#?} block {}",
            //     node, node.direct_blocks[0]
            // );
            return Some(self.get_data_block(node.direct_blocks[0]));
        }
        None
    }

    fn create_file_inter(&mut self, node: &inode_t, name: &[u8], content: &[u8]) {
        let mut i = 0usize;
        let inode_num = self.inode_bitmap.get_first_free();
        let block_num = self.blocks_bitmap.get_first_free();

        //create dentry
        let data = self.get_data_block_mut(node.direct_blocks[0]);
        while let Some(dentry) = Dentry::from(&data[i..]) {
            i += dentry.size;
        }
        data[i..i + 4].copy_from_slice(&(inode_num as u32).to_le_bytes());
        let name_len = name.len();
        data[i + 4..i + 8].copy_from_slice(&(name_len as u32).to_le_bytes());
        data[i + 8..i + 8 + name_len].copy_from_slice(name);

        //create inode
        self.create_inode(inode_num, block_num);

        //create data block
        self.get_data_block_mut(block_num as u32)[0..content.len()].copy_from_slice(content)
    }

    pub fn test(&self) {
        //println!("{:?}", self.get_inode_by_id(1));
        //println!("{:?}", self.get_inode_by_id(2));
    }

    fn search_directory(&self, node: &inode_t, path: &CStr) -> Option<inode_t> {
        let mut i = 0usize;
        let data = self.get_data_block(node.direct_blocks[0]);

        let filename = if let Some(offset) = path.to_str().expect("invalid dir name").find('/') {
            &path.to_str().unwrap()[0..offset]
        } else {
            path.to_str().unwrap()
        };
        //println!("searching filename {}", filename);
        while let Some(dentry) = Dentry::from(&data[i..]) {
            if dentry.name.to_str().expect("name to str failed") == filename {
                //println!("inode num {}", dentry.inode_num);
                return Some(self.get_inode_by_id(dentry.inode_num));
            } else {
                //println!("{} {}", dentry.name.to_str().expect("g"), filename);
            }
            i += dentry.size;
        }
        None
    }

    fn get_inode_by_id(&self, id: inode_p) -> inode_t {
        if id == 0 {
            panic!("invalid inode id");
        }
        let start = (128 * id) as usize;
        let data: [u8; 128] = self.inodes[start..start + 128]
            .try_into()
            .expect(&format!("failed to load inode {}", id));
        zerocopy::transmute!(data)
    }

    pub fn get_inode(&mut self, path: &CStr) {
        let d: [u8; 128] = self.inodes[0..128].try_into().unwrap();
        let root: inode_t = zerocopy::transmute!(d);
        self.search_directory(&root, path);
    }

    pub fn create_inode(&mut self, i: usize, b: usize) {
        // let i = self.inode_bitmap.get_first_free();
        let mut blocks = [0u32; 12];
        blocks[0] = b as u32; //self.blocks_bitmap.get_first_free() as u32;
        println!("block {}", blocks[0]);
        let time = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .expect("time went back")
            .as_secs();
        //let data: [u8; 128] = .try_into().unwrap();
        let node = inode_t {
            type_perm: 255,
            uid: 1,
            gid: 1,
            pad1: 0,
            size: 0,
            pad2: 0,
            access_time: time,
            mod_time: time,
            creat_time: time,
            hard_links: 2,
            direct_blocks: blocks,
            sin_inblock: 0,
            dob_inblock: 0,
            tri_inblock: 0,
            unused: [0i8; 24],
        };
        let data: [u8; 128] = zerocopy::transmute!(node);
        self.inodes[i * 128..(i + 1) * 128].copy_from_slice(&data);
    }

    fn get_data_block_mut(&mut self, id: block_p) -> &mut [u8] {
        let offset = (id * self.sb.block_size) as usize;
        return &mut self.data_blocks[offset..offset + self.sb.block_size as usize];
    }

    fn get_data_block(&self, id: block_p) -> &[u8] {
        let offset = (id * self.sb.block_size) as usize;
        return &self.data_blocks[offset..offset + self.sb.block_size as usize];
    }

    fn get_blocks_mut(&mut self, start: block_p, end: block_p) -> &mut [u8] {
        let s = (start * self.sb.block_size) as usize;
        let e = (end * self.sb.block_size) as usize;
        return &mut self.data[s..e];
    }

    fn get_blocks(&self, start: block_p, end: block_p) -> &[u8] {
        let s = (start * self.sb.block_size) as usize;
        let e = (end * self.sb.block_size) as usize;
        return &self.data[s..e];
    }

    fn get_block(&self, id: block_p) -> &[u8] {
        let start = (id * self.sb.block_size) as usize;
        let end = start + self.sb.block_size as usize;
        return &self.data[start..end];
    }

    //    fn find_free_inode(&self) -> inode_t {}
}

#[derive(Debug)]
struct Bitmap<'a> {
    data: &'a mut [u8],
    size: usize,
}

impl<'a> Bitmap<'a> {
    pub fn new(data: &'a mut [u8], size: usize) -> Self {
        if (data.len() * 8 < size) {
            panic!("buffer to small to create bitmap");
        }
        Bitmap { data, size }
    }

    pub fn take(&mut self, id: usize) {
        self.data[id / 8] |= 1 << id % 8;
        // println!("{:?}", self.data);
    }

    pub fn get_first_free(&mut self) -> usize {
        let mut i = 1;
        while i < self.size {
            if self.data[i / 8] & 1 << i % 8 == 0 {
                self.data[i / 8] |= 1 << i % 8;
                return i;
            }
            i += 1;
        }
        return 0;
    }
}

struct Dentry<'a> {
    inode_num: inode_p,
    name: &'a CStr,
    size: usize,
}

impl<'a> Dentry<'a> {
    fn from(data: &'a [u8]) -> Option<Self> {
        if data.len() < 8 {
            println!("too small");
            return None;
            //"dentry too small"
        }
        let inode_num = inode_p::from_le_bytes(data[0..4].try_into().unwrap());
        if inode_num == 0 {
            println!("inode 0");
            return None;
        }
        let size = u32::from_le_bytes(data[4..8].try_into().unwrap());
        if data.len() < (8 + size) as usize {
            println!("size wrong");
            return None;
            //"dir name size incorrect"
        }
        Some(Self {
            inode_num,
            name: CStr::from_bytes_with_nul(&data[8..8 + size as usize]).expect(&format!(
                "bad file name {:?} size = {}",
                &data[8..8 + size as usize],
                size
            )),
            size: size as usize + 8,
        })
    }
}

#[repr(C)]
#[derive(Debug, Copy, Clone, zerocopy_derive::FromBytes, zerocopy_derive::IntoBytes)]
pub struct superblock_t {
    pub header: [::std::os::raw::c_char; 8usize],
    pub inodes_num: ::std::os::raw::c_uint,
    pub blocks_num: ::std::os::raw::c_uint,
    pub block_size: ::std::os::raw::c_uint,
    pub free_blocks: ::std::os::raw::c_uint,
    pub free_inodes: ::std::os::raw::c_uint,
}

#[derive(Debug)]
pub struct Goo<const T: usize> {
    pub goo: [u8; T],
}

//#[repr()]
#[derive(zerocopy_derive::FromBytes, zerocopy_derive::IntoBytes, Debug)]
pub struct Boo {
    pub x: f32,
    pub y: f32,
    pub c: [u8; 20],
}

impl From<[i8; 8]> for superblock_t {
    fn from(value: [i8; 8]) -> Self {
        superblock_t {
            header: [0; 8],
            inodes_num: 1, //u32::from_le_bytes(value[4..].try_into().unwrap()),
            blocks_num: 1, /*value[0..4].try_into().unwrap()*/
            block_size: 1,
            free_blocks: 1,
            free_inodes: 1,
        }
    }
}

impl From<Foo> for superblock_t {
    fn from(value: Foo) -> Self {
        superblock_t {
            header: [0; 8],
            inodes_num: value.x as u32,
            blocks_num: 1,
            block_size: 1,
            free_blocks: 1,
            free_inodes: 1,
        }
    }
}

#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of superblock_t"][::std::mem::size_of::<superblock_t>() - 28usize];
    ["Alignment of superblock_t"][::std::mem::align_of::<superblock_t>() - 4usize];
    ["Offset of field: superblock_t::header"]
        [::std::mem::offset_of!(superblock_t, header) - 0usize];
    ["Offset of field: superblock_t::inodes_num"]
        [::std::mem::offset_of!(superblock_t, inodes_num) - 8usize];
    ["Offset of field: superblock_t::blocks_num"]
        [::std::mem::offset_of!(superblock_t, blocks_num) - 12usize];
    ["Offset of field: superblock_t::block_size"]
        [::std::mem::offset_of!(superblock_t, block_size) - 16usize];
    ["Offset of field: superblock_t::free_blocks"]
        [::std::mem::offset_of!(superblock_t, free_blocks) - 20usize];
    ["Offset of field: superblock_t::free_inodes"]
        [::std::mem::offset_of!(superblock_t, free_inodes) - 24usize];
};
pub type block_p = ::std::os::raw::c_uint;
pub type inode_p = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, zerocopy_derive::FromBytes, zerocopy_derive::IntoBytes)]
pub struct inode_t {
    pub type_perm: ::std::os::raw::c_ushort,
    pub uid: ::std::os::raw::c_ushort,
    pub gid: ::std::os::raw::c_ushort,
    pub pad1: ::std::os::raw::c_ushort,
    pub size: ::std::os::raw::c_uint,
    pub pad2: ::std::os::raw::c_uint,
    pub access_time: ::std::os::raw::c_ulonglong,
    pub mod_time: ::std::os::raw::c_ulonglong,
    pub creat_time: ::std::os::raw::c_ulonglong,
    pub hard_links: ::std::os::raw::c_uint,
    pub direct_blocks: [block_p; 12usize],
    pub sin_inblock: block_p,
    pub dob_inblock: block_p,
    pub tri_inblock: block_p,
    pub unused: [::std::os::raw::c_char; 24usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of inode_t"][::std::mem::size_of::<inode_t>() - 128usize];
    ["Alignment of inode_t"][::std::mem::align_of::<inode_t>() - 8usize];
    ["Offset of field: inode_t::type_perm"][::std::mem::offset_of!(inode_t, type_perm) - 0usize];
    ["Offset of field: inode_t::uid"][::std::mem::offset_of!(inode_t, uid) - 2usize];
    ["Offset of field: inode_t::gid"][::std::mem::offset_of!(inode_t, gid) - 4usize];
    ["Offset of field: inode_t::size"][::std::mem::offset_of!(inode_t, size) - 8usize];
    ["Offset of field: inode_t::access_time"]
        [::std::mem::offset_of!(inode_t, access_time) - 16usize];
    ["Offset of field: inode_t::mod_time"][::std::mem::offset_of!(inode_t, mod_time) - 24usize];
    ["Offset of field: inode_t::creat_time"][::std::mem::offset_of!(inode_t, creat_time) - 32usize];
    ["Offset of field: inode_t::hard_links"][::std::mem::offset_of!(inode_t, hard_links) - 40usize];
    ["Offset of field: inode_t::direct_blocks"]
        [::std::mem::offset_of!(inode_t, direct_blocks) - 44usize];
    ["Offset of field: inode_t::sin_inblock"]
        [::std::mem::offset_of!(inode_t, sin_inblock) - 92usize];
    ["Offset of field: inode_t::dob_inblock"]
        [::std::mem::offset_of!(inode_t, dob_inblock) - 96usize];
    ["Offset of field: inode_t::tri_inblock"]
        [::std::mem::offset_of!(inode_t, tri_inblock) - 100usize];
    ["Offset of field: inode_t::unused"][::std::mem::offset_of!(inode_t, unused) - 104usize];
};
extern "C" {
    pub fn get_block(sb: *mut superblock_t, id: block_p) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn get_inode_by_id(sb: *mut superblock_t, id: inode_p) -> *mut inode_t;
}
extern "C" {
    pub fn take_inode(sb: *mut superblock_t, id: inode_p);
}
extern "C" {
    pub fn get_free_data_block(sb: *mut superblock_t) -> block_p;
}
extern "C" {
    pub fn test(sb: *mut superblock_t);
}
extern "C" {
    pub fn find_free_inode(sb: *mut superblock_t) -> inode_p;
}
extern "C" {
    pub fn find_inode_by_path(
        sb: *mut superblock_t,
        path: *const ::std::os::raw::c_char,
    ) -> *mut inode_t;
}
extern "C" {
    pub fn search_dir(cur: *mut inode_t, path: *const ::std::os::raw::c_char) -> *mut inode_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dentry_t_t {
    pub inode: inode_p,
    pub size: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of dentry_t_t"][::std::mem::size_of::<dentry_t_t>() - 8usize];
    ["Alignment of dentry_t_t"][::std::mem::align_of::<dentry_t_t>() - 4usize];
    ["Offset of field: dentry_t_t::inode"][::std::mem::offset_of!(dentry_t_t, inode) - 0usize];
    ["Offset of field: dentry_t_t::size"][::std::mem::offset_of!(dentry_t_t, size) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct filesystem_t {
    pub sb: superblock_t,
    pub inodes: *mut inode_t,
    pub blocks: *mut block_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of filesystem_t"][::std::mem::size_of::<filesystem_t>() - 48usize];
    ["Alignment of filesystem_t"][::std::mem::align_of::<filesystem_t>() - 8usize];
    ["Offset of field: filesystem_t::sb"][::std::mem::offset_of!(filesystem_t, sb) - 0usize];
    ["Offset of field: filesystem_t::inodes"]
        [::std::mem::offset_of!(filesystem_t, inodes) - 32usize];
    ["Offset of field: filesystem_t::blocks"]
        [::std::mem::offset_of!(filesystem_t, blocks) - 40usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct block_t {
    pub _address: u8,
}
